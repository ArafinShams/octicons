#!/usr/bin/env node
const fse = require('fs-extra')
const nunjucks = require('nunjucks')
const octicons = require('..')
const path = require('path')
const permutron = require('permutron')
const sharp = require('sharp')
const PromiseQueue = require('p-queue')
const ObjectAssign = require('object-assign')

const getColors = () => {
  const colorVarsPath = require.resolve(
    'primer-support/lib/variables/color-system.scss'
  )

  const parseVariables = scss => {
    const matches = scss.match(/\$([-\w]+:\s*#\w+)/g)
    return Array.from(matches)
      .slice(1)
      .map(pair => {
        if (pair.charAt(0) === '$') {
          pair = pair.substr(1)
        }
        const [name, value] = pair.split(/:\s*/)
        return {name, value}
      })
  }

  return fse.readFile(colorVarsPath, 'utf8')
    .then(parseVariables)
}

const generator = (handler) => {
  return (context) => {
    delete context._
    const {limit} = context
    const _limit = limit > 0
      ? d => d.slice(0, limit)
      : d => d
    return Promise.resolve(
        Object.keys(octicons).map(name => octicons[name])
      )
      .then(_limit)
      .then(icons => {
        console.warn('got %d octicons', icons.length)
        return ObjectAssign(context, {icons})
      })
      .then(getColors)
      .then(_limit)
      .then(colors => {
        console.warn('got %d colors', colors.length)
        return ObjectAssign(context, {colors})
      })
      // finally call the handler with the context
      .then(() => handler(context))
      .then(results => {
        if (results) {
          console.warn('generated %d images', results.length)
        } else {
          console.warn('all done!')
        }
      })
      .catch(error => {
        console.error('unable to generate:', error)
        process.exit(1)
      })
  }
}

const generateFromMatrix = (context, generate, ext) => {
  const {icons, colors, sizes} = context
  return new Promise((resolve, reject) => {
    const results = []
    permutron.object({
      icon: icons,
      color: colors,
      size: sizes,
    },
    (data, next) => {
      generate(data).then(result => {
        results.push(result)
        next()
      })
    },
    (error) => {
      if (error) {
        reject(error)
      } else {
        resolve(results)
      }
    })
  })
}

const writeIcon = (buffer, {icon, color, size}, ext, outdir) => {
  const basename = icon.symbol
  const filename = size
    ? `${basename}@${size}.${ext}`
    : `${basename}.${ext}`
  const outfile = path.join(outdir, color.name, filename)
  const outpath = path.dirname(outfile)
  return fse.mkdirp(outpath)
    .then(() => fse.writeFile(outfile, buffer))
    // resolve with the generated path
    .then(() => outfile)
}

const svgize = (icon, color, size) => {
  const svg = icon.toSVG({
    // we need to add the XML namespace for standalone files
    xmlns: 'http://www.w3.org/2000/svg',
    fill: color.value,
    height: size,
  })
  return Promise.resolve(`<?xml version="1.0"?>\n${svg}`)
}

const replaceExt = (filename, ext) => {
  return filename.replace(/\.\w+$/, ext)
}

const rasterize = (svg, size) => {
  const buffer = new Buffer(svg)
  return sharp(buffer)
    .toFormat(sharp.format.png)
    .toBuffer()
}

const generateSVGs = context => {
  return generateFromMatrix(context, data => {
      const {icon, color} = data
      const {outdir} = context
      delete data.size
      return svgize(icon, color)
        .then(svg => writeIcon(svg, data, 'svg', outdir))
        .then(svg => ObjectAssign(context, {svg}))
    })
    .then(svgs => {
      return generateHTML(context)
        .then(() => svgs)
    })
}

const generatePNGs = context => {
  const {outdir} = context
  const queue = new PromiseQueue({concurrency: 3})
  return generateFromMatrix(context, data => {
      const {icon, color, size} = data
      return queue.add(() => {
        return svgize(icon, color, size)
          .then(rasterize)
          .then(png => writeIcon(png, data, 'png', outdir))
      })
    })
    .then(() => queue.onIdle())
    .then(() => generateHTML(context))
}

const generateHTML = context => {
  return new Promise((resolve, reject) => {
    const template = require.resolve('../lib/templates/images.html')
    console.warn('generating index...')
    context.formats = ['svg', 'png']
    nunjucks.render(template, context, (error, html) => {
      if (error) {
        reject(error)
      } else {
        const outpath = path.join(context.outdir, 'index.html')
        console.warn('writing index to', outpath)
        resolve(fse.writeFile(outpath, html, 'utf8'))
      }
    })
  })
}

require('yargs')
  .usage('$0 <command> [options]')
  .options({
    outdir: {
      alias: 'o',
      describe: 'the output directory',
      global: true,
      default: 'build/images',
    },
    sizes: {
      alias: 's',
      type: 'array',
      describe: 'One or more square sizes in pixels',
      global: true,
      default: [64],
    },
    limit: {
      alias: 'l',
      type: 'number',
      describe: 'Limit number of files to output, for debugging',
    }
  })
  .command('svg', 'generate colored SVG files', {},
           generator(generateSVGs))
  .command('png', 'generate colored PNG files', {},
           generator(generatePNGs))
  .command('html', 'generate the HTML index', {},
           generator(generateHTML))
  .demandCommand(1, 'Please provide a command')
  .help()
  .strict(true)
  .argv
